# Program for balancing wind allocation in mahjong tournaments
# Designed for use with schedules generated by https://breakoutroom.pythonanywhere.com/allocate/
# Works for any schedule with a [player1, player2, player3, player4] format
# Uses find & replace to create the output, so does not work if any matches are exact copies of each other
# Works by finding swaps that improve allocation & repeating until it cannot find any way to improve it
# There may be a series of 2 or 3 swaps that improve it, so it is necessarily the perfect allocation, just a good one

import copy
import re


def inc(dictionary, key):
    dictionary[key] = dictionary.get(key, 0) + 1


def dec(dictionary, key):
    dictionary[key] = dictionary.get(key, 0) - 1


# Simulate the effect of swapping 2 positions
# Return True if it improves the wind allocation
def testSwap(dictionary, match, x, y):
    a = dictionary[x].get(match[x], 0)
    b = dictionary[x].get(match[y], 0)
    c = dictionary[y].get(match[x], 0)
    d = dictionary[y].get(match[y], 0)
    currentScore = a*a + b*b + c*c + d*d
    a -= 1
    b += 1
    c += 1
    d -= 1
    newScore = a*a + b*b + c*c + d*d
    return newScore < currentScore


def assign(inputFile):
    file = open(inputFile, "r")
    text = file.read()
    file.close()
    capture = re.findall("\[(.*?), ?(.*?), ?(.*?), ?(.*?)]", text)
    lockedInCapture = copy.deepcopy(capture)
    playerSet = set()
    for x in capture:  # makes a list of players for audit (in case of using names instead of numbers)
        playerSet.add(x[0])
        playerSet.add(x[1])
        playerSet.add(x[2])
        playerSet.add(x[3])
    changed = True
    while changed:  # run until the allocation stops improving
        changed = False
        counts = [{}, {}, {}, {}]
        for match in capture:  # calculate current allocation
            inc(counts[0], match[0])
            inc(counts[1], match[1])
            inc(counts[2], match[2])
            inc(counts[3], match[3])
        for index in range(len(capture)):
            if testSwap(counts, capture[index], 0, 1):  # If swapping improves the allocation
                dec(counts[0], capture[index][0])  # then perform the swap
                dec(counts[1], capture[index][1])
                inc(counts[1], capture[index][0])
                inc(counts[0], capture[index][1])
                capture[index] = (capture[index][1], capture[index][0], capture[index][2], capture[index][3])
                changed = True
            if testSwap(counts, capture[index], 0, 2):
                dec(counts[0], capture[index][0])
                dec(counts[2], capture[index][2])
                inc(counts[2], capture[index][0])
                inc(counts[0], capture[index][2])
                capture[index] = (capture[index][2], capture[index][1], capture[index][0], capture[index][3])
                changed = True
            if testSwap(counts, capture[index], 0, 3):
                dec(counts[0], capture[index][0])
                dec(counts[3], capture[index][3])
                inc(counts[3], capture[index][0])
                inc(counts[0], capture[index][3])
                capture[index] = (capture[index][3], capture[index][1], capture[index][2], capture[index][0])
                changed = True
            if testSwap(counts, capture[index], 1, 2):
                dec(counts[1], capture[index][1])
                dec(counts[2], capture[index][2])
                inc(counts[1], capture[index][2])
                inc(counts[2], capture[index][1])
                capture[index] = (capture[index][0], capture[index][2], capture[index][1], capture[index][3])
                changed = True
            if testSwap(counts, capture[index], 1, 3):
                dec(counts[1], capture[index][1])
                dec(counts[3], capture[index][3])
                inc(counts[1], capture[index][3])
                inc(counts[3], capture[index][1])
                capture[index] = (capture[index][0], capture[index][3], capture[index][2], capture[index][1])
                changed = True
            if testSwap(counts, capture[index], 2, 3):
                dec(counts[2], capture[index][2])
                dec(counts[3], capture[index][3])
                inc(counts[2], capture[index][3])
                inc(counts[3], capture[index][2])
                capture[index] = (capture[index][0], capture[index][1], capture[index][3], capture[index][2])
                changed = True
    index = 0
    for match in lockedInCapture:  # find the previous arrangement
        find = "{}, {}, {}, {}".format(match[0], match[1], match[2], match[3])
        match = capture[index]  # replace with new arrangement
        replace = "{}, {}, {}, {}".format(match[0], match[1], match[2], match[3])
        index += 1
        text = text.replace(find, replace)
    file = open("output.txt", "w")
    file.write(text)
    file.close()
    file = open("audit.txt", "w")
    try:  # if players are numbered, sort by number
        playerList = sorted(playerSet, key=lambda item: int(item))
    except:  # otherwise, sort alphabetically
        playerList = sorted(playerSet)
    for x in playerList:  # Print out the wind assignment for each player
        file.write("{}\n".format(x))
        file.write("East: {}\n".format(counts[0].get(x, 0)))
        file.write("South: {}\n".format(counts[1].get(x, 0)))
        file.write("West: {}\n".format(counts[2].get(x, 0)))
        file.write("North: {}\n".format(counts[3].get(x, 0)))
        file.write("\n")
    file.close()


assign("input.txt")
